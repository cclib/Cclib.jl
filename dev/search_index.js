var documenterSearchIndex = {"docs":
[{"location":"calculation/#Additional-Analyses","page":"Additional analyses","title":"Additional Analyses","text":"","category":"section"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"Cclib also allows to further analyse calculation ouputs.","category":"page"},{"location":"calculation/#C-squared-population-analysis-(CSPA)","page":"Additional analyses","title":"C squared population analysis (CSPA)","text":"","category":"section"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"CSPA can be used to determine and interpret the electron density of a molecule. The contribution of the a-th atomic orbital to the i-th molecular orbital can be written in terms of the molecular orbital coefficients:","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"Phi_ai = fracc^2_aisum_k c^2_ki","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"# Example calculation files can be found in the test folder of the main branch.\njulia> using Cclib\njulia> aoresults, fragresults, fragcharges = cspa(\"./Trp_polar.fchk\")","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"aoresults: a three dimensional array with spin, molecular orbital, and atomic orbitals as the axes, so that aoresults1 46 1 gives the contribution of the 1st atomic orbital to the 46th alpha/restricted molecular orbital,\nfragresults: a three dimensional array with spin, molecular orbital, and atoms as the axes, so that fragresults1 24 5 gives the contribution of the 5th fragment orbitals to the 24th beta molecular orbital)\nfragcharges: a vector with the number of (partial) electrons in each fragment, so that fragcharges3 gives the number of electrons in the 3rd fragment.","category":"page"},{"location":"calculation/#Mulliken-population-analysis-(MPA)","page":"Additional analyses","title":"Mulliken population analysis (MPA)","text":"","category":"section"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"MPA can be used to determine and interpret the electron density of a molecule. The contribution of the a-th atomic orbital to the i-th molecular orbital in this method is written in terms of the molecular orbital coefficients, c, and the overlap matrix, S:","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"Phi_ai = sum_b c_ai c_bi S_ab","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"julia> using Cclib\njulia> aoresults, fragresults, fragcharges = mpa(\"./Trp_polar.fchk\")","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"aoresults: a three dimensional array with spin, molecular orbital, and atomic orbitals as the axes, so that aoresults1 46 1 gives the contribution of the 1st atomic orbital to the 46th alpha/restricted molecular orbital,\nfragresults: a three dimensional array with spin, molecular orbital, and atoms as the axes, so that fragresults1 24 5 gives the contribution of the 5th fragment orbitals to the 24th beta molecular orbital)\nfragcharges: a vector with the number of (partial) electrons in each fragment, so that fragcharges3 gives the number of electrons in the 3rd fragment.","category":"page"},{"location":"calculation/#LÃ¶wdin-Population-Analysis","page":"Additional analyses","title":"LÃ¶wdin Population Analysis","text":"","category":"section"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"julia> using Cclib\njulia> aoresults, fragresults, fragcharges = lpa(\"./Trp_polar.fchk\")","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"aoresults: a three dimensional array with spin, molecular orbital, and atomic orbitals as the axes, so that aoresults1 46 1 gives the contribution of the 1st atomic orbital to the 46th alpha/restricted molecular orbital,\nfragresults: a three dimensional array with spin, molecular orbital, and atoms as the axes, so that fragresults1 24 5 gives the contribution of the 5th fragment orbitals to the 24th beta molecular orbital)\nfragcharges: a vector with the number of (partial) electrons in each fragment, so that fragcharges3 gives the number of electrons in the 3rd fragment.","category":"page"},{"location":"calculation/#Bickelhaupt-Population-Analysis","page":"Additional analyses","title":"Bickelhaupt Population Analysis","text":"","category":"section"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"The Bickelhaupt class available from cclib.method performs Bickelhaupt population analysis that has been proposed in Organometallics 1996, 15, 13, 2923â€“2931. doi:10.1021/om950966x","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"The contribution of the a-th atomic orbital to the i-th molecular orbital in this method is written in terms of the molecular orbital coefficients, c, and the overlap matrix, S:","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"Phi_aialpha = sum_b w_abalpha c_aialpha c_bialpha S_ab","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"where the weights w_ab that are applied on the Mulliken atomic orbital contributions are defined as following when the coefficients of the molecular orbitals are substituted into equation 11 in the original article.","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"w_abalpha = 2 fracsum_k c_akalpha^2sum_i c_aialpha^2 + sum_j c_bjalpha^2","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"In case of unrestricted calculations, alpha charges and beta charges are each determined to obtain total charge. In restricted calculations, alpha subscript can be ignored since the coefficients are equivalent for both spin orbitals.","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"The weights are introduced to replace the somewhat arbitrary partitioning of off-diagonal charges in the Mulliken population analysis, which divides the off-diagonal charges identically to both atoms. Bickelhaupt population analysis instead divides the off-diagonal elements based on the relative magnitude of diagonal elements.","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"julia> using Cclib\njulia> aoresults, fragresults, fragcharges = bpa(\"./Trp_polar.fchk\")","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"aoresults: a three dimensional array with spin, molecular orbital, and atomic orbitals as the axes, so that aoresults1 46 1 gives the contribution of the 1st atomic orbital to the 46th alpha/restricted molecular orbital,\nfragresults: a three dimensional array with spin, molecular orbital, and atoms as the axes, so that fragresults1 24 5 gives the contribution of the 5th fragment orbitals to the 24th beta molecular orbital)\nfragcharges: a vector with the number of (partial) electrons in each fragment, so that fragcharges3 gives the number of electrons in the 3rd fragment.","category":"page"},{"location":"calculation/#Density-Matrix-calculation","page":"Additional analyses","title":"Density Matrix calculation","text":"","category":"section"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"Calculates the electron density matrix","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"julia> using Cclib\njulia> result = density(\"./Trp_polar.fchk\")","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"Returns an array with three axes. The first axis is for the spin contributions, the second and the third axes for the density matrix, which follows standard definition.","category":"page"},{"location":"calculation/#Mayerâ€™s-Bond-Orders-(MBO)","page":"Additional analyses","title":"Mayerâ€™s Bond Orders (MBO)","text":"","category":"section"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"Calculates Mayer's bond orders","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"julia> using Cclib\njulia> result = mbo(\"./Trp_polar.fchk\")","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"Returns an array with three axes. The first axis is for contributions of each spin to the MBO, while the second and the third correspond to the indices of the atoms.","category":"page"},{"location":"calculation/#Charge-Decomposition-Analysis","page":"Additional analyses","title":"Charge Decomposition Analysis","text":"","category":"section"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"The Charge Decomposition Analysis (CDA) as developed by Gernot Frenking et al. is used to study the donor-acceptor interactions of a molecule in terms of two user-specified fragments.","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"julia> using Cclib\njulia> donations, bdonations, repulsions = cda(\"BH3CO-sp.log\", \"BH3.log\", \"CO.log\")","category":"page"},{"location":"calculation/","page":"Additional analyses","title":"Additional analyses","text":"Returns donations, bdonations (back donations), and repulsions attributes. These attributes are simply lists of 1-dimensional arrays corresponding to the restricted or alpha/beta molecular orbitals of the entire molecule.","category":"page"},{"location":"interop/#Interoperability-With-Other-Tools","page":"Interoperability with other tools","title":"Interoperability With Other Tools","text":"","category":"section"},{"location":"interop/#AtomsBase.jl","page":"Interoperability with other tools","title":"AtomsBase.jl","text":"","category":"section"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"Cclib.jl provides interoperability with AtomsBase.jl by allowing to create AtomsBase systems.","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"The documentaiton below provides some essential functionality, such as creating and editing AtomsBase.jl systems.","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"For a detailed overview, or if you want to know how AtomsBase.jl operates behind the scenes, refer to its official documentation.","category":"page"},{"location":"interop/#Creating-AtomsBase-Systems","page":"Interoperability with other tools","title":"Creating AtomsBase Systems","text":"","category":"section"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"We can load information contained in a Cclib.jl-supported file into a system by using the following functions:","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"make_flexible_system - for creating an AtomsBase FlexibleSystem","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"# Input file can be found in the in the repo under \"test\" folder\njulia> using Cclib\njulia> using Unitful\njulia> using AtomsBase\njulia> box = [[3.0, 0.0, 0.0], [0.0, 3.0, 0.0], [0.0, 0.0, 3.0]]u\"Ã…\"\njulia> boundary_conditions = [Periodic(), Periodic(), Periodic()]\njulia> system = make_flexible_system(\"./water_mp2.out\", box, boundary_conditions)\n\nFlexibleSystem(Hâ‚‚O, periodic = TTT):\n    bounding_box      : [       3        0        0;\n                                0        3        0;\n                                0        0        3]u\"Ã…\"\n\n    Atom(O,  [       0,        0, -0.0666785]u\"Ã…\")\n    Atom(H,  [       0, -0.790649, 0.529118]u\"Ã…\")\n    Atom(H,  [       0, 0.790649, 0.529118]u\"Ã…\")\n\n      .------.\n     /|      |\n    O |      |\n    | |      |\n    |H.------.\n    |H      /\n    *------*\n","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"make_isolated_system - for creating an AtomsBase isolated_system","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"julia> using Cclib\njulia> system = make_isolated_system(\"./water_mp2.out\")\n\nFlexibleSystem(Hâ‚‚O, infinite):\n    Atom(O,  [       0,        0, -0.0666785]u\"Ã…\")\n    Atom(H,  [       0, -0.790649, 0.529118]u\"Ã…\")\n    Atom(H,  [       0, 0.790649, 0.529118]u\"Ã…\")","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"get_atom_objects - for getting an array of AtomsBase Atom objects in case you need more control.","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"julia> using Cclib\njulia> using AtomsBase\njulia> mol = ccread(\"./water_mp2.out\")\njulia> atoms = get_atom_objects(mol)\njulia> atoms[1]\n\nAtom(O, atomic_number = 8, atomic_mass = 15.999 u):\n    position          : [0,0,-0.066678532]u\"Ã…\"","category":"page"},{"location":"interop/#Accessing-System-Properties","page":"Interoperability with other tools","title":"Accessing System Properties","text":"","category":"section"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"In case we need to look at what our system contains, we can use regular keys to see available system-level properties and atomkeys to see available atom-level properties","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"julia> using Cclib\njulia> using AtomsBase\njulia> system = make_isolated_system(\"./water_mp2.out\")\n\njulia> keys(system)\n(:bounding_box, :boundary_conditions)\n\njulia> atomkeys(system)\n(:position, :velocity, :atomic_symbol, :atomic_number, :atomic_mass)\n\njulia> bounding_box(system)\n [Inf aâ‚€, 0.0 aâ‚€, 0.0 aâ‚€]\n [0.0 aâ‚€, Inf aâ‚€, 0.0 aâ‚€]\n [0.0 aâ‚€, 0.0 aâ‚€, Inf aâ‚€\n\n julia> atomic_symbol(system)\n 3-element Vector{Symbol}:\n :O\n :H\n :H","category":"page"},{"location":"interop/#Updating-and/or-adding-system-properties","page":"Interoperability with other tools","title":"Updating and/or adding system properties","text":"","category":"section"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"We can also update and/or add system properties by using update_system function that accepts keywords arguments. Below is an example of adding data that was parsed using ccread to a system.","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"julia> using Cclib\njulia> mol = ccread(\"./water_mp2.out\")\njulia> system = make_isolated_system(mol);\njulia> system = update_system(system; nbasis=mol[\"nbasis\"])\njulia> system[:nbasis]\n7","category":"page"},{"location":"interop/#AtomsBase.jl-supported-libraries","page":"Interoperability with other tools","title":"AtomsBase.jl-supported libraries","text":"","category":"section"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"We can use data loaded with Cclib.jl to perform calculations using other libraries that use AtomsBase.jl, such as InteratomicPotentials.jl or DFTK.jl.","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"Let's first load some dependencies and make a system","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"julia> using Cclib\njulia> using AtomsBase\njulia> using Unitful\njulia> using UnitfulAtomic\njulia> using InteratomicPotentials\njulia> using DFTK\n\njulia> box = [[3.0, 0.0, 0.0], [0.0, 3.0, 0.0], [0.0, 0.0, 3.0]]u\"Ã…\"\njulia> boundary_conditions = [Periodic(), Periodic(), Periodic()]\njulia> system = make_flexible_system(\"./water_mp2.out\", box, boundary_conditions);","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"We can now perform calculate various properties of the system:","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"using InteratomicPotentials.jl","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"julia> Ïµ = 1.0 * 1u\"eV\"\njulia> Ïƒ = 0.25 * 1u\"â„«\"\njulia> rcutoff  = 2.25 * 1u\"â„«\"\njulia> lj = LennardJones(Ïµ, Ïƒ, rcutoff, [:N, :C, :O, :H])\njulia> potential_energy(system, lj)\n-8.061904291397444e-5 Eâ‚•","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"using DFTK.jl","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"model  = model_LDA(system; temperature=1e-3)\nbasis  = PlaneWaveBasis(model; Ecut=15, kgrid=(3, 3, 3))\nself_consistent_field(basis);\nn     Energy            log10(Î”E)   log10(Î”Ï)   Diag   Î”time\n---   ---------------   ---------   ---------   ----   ------\n  1   -38.18166038243                    0.81    5.2\n  2   -45.38103756530        0.86        0.12    3.0    253ms\n  3   -45.54220597356       -0.79       -0.74    3.0    273ms\n  4   -45.55809718591       -1.80       -1.40    2.1    172ms\n  5   -45.55889514812       -3.10       -2.14    1.0    159ms\n  6   -45.55892123307       -4.58       -2.63    1.4    158ms\n  7   -45.55892315420       -5.72       -3.26    1.8    211ms\n  8   -45.55892314370   +   -7.98       -3.57    1.2    113ms\n  9   -45.55892319258       -7.31       -3.92    2.0    189ms\n 10   -45.55892320440       -7.93       -4.94    1.1    142ms\n 11   -45.55892320464       -9.63       -4.96    2.0    185ms\n 12   -45.55892320468      -10.33       -5.44    1.0    134ms\n 13   -45.55892320469      -11.36       -6.15    2.0    158ms","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"For a full list of tools that support AtomsBase.jl, refer to its official documentation.","category":"page"},{"location":"interop/#Fermi.jl","page":"Interoperability with other tools","title":"Fermi.jl","text":"","category":"section"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"We can use information loaded using Cclib and use it for Fermi.jl calculations, which accept atom numbers and XYZ coordinates as input. The latter is accessible using Cclib's getXYZ function.","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"Note that files may contain more than one geometry, in which case the index of the geometry can be specified by passing geomIdx argument to getXYZ. Be default, getXYZ will use the last read geometry.","category":"page"},{"location":"interop/","page":"Interoperability with other tools","title":"Interoperability with other tools","text":"julia> using Cclib\njulia> using Fermi # make sure to install using \"add Fermi#master\"\njulia> xyzfile = getXYZ(\"./test/data/Trp_polar.fchk\")\njulia> mol = Molecule(molstring=xyzfile)\njulia> @set basis sto-3g\njulia> @energy rhf # this line should produce something similar to what is below.\n================================================================================\n|                                 Hartree-Fock                                 |\n|                                  Module  by                                  |\n|                         G.J.R Aroeira and M.M. Davis                         |\n================================================================================\nCollecting necessary integrals...\nDone in    0.44575 s\nUsing GWH Guess\nMolecule:\n\nO    1.209153654800    1.766411818900   -0.017161397200\nH    2.198480007500    1.797710062700    0.012116171900\nH    0.919788188200    2.458018557000    0.629793883200\n\n\nCharge: 0   Multiplicity: 1\n\nNuclear repulsion:    8.8880641737\n Number of AOs:                            7\n Number of Doubly Occupied Orbitals:       5\n Number of Virtual Spatial Orbitals:       2\n Guess Energy   -83.52857161946045\n\n Iter.            E[RHF]         Î”E       Dáµ£â‚˜â‚›        t     DIIS     damp\n--------------------------------------------------------------------------------\n    1    -74.9454656296  -7.495e+01   1.011e-01     0.12    false     2.18\n    2    -74.8779931590   6.747e-02   4.129e-02     0.00    false     1.47\n    3    -74.7758359210   1.022e-01   3.788e-02     0.00    false     0.00\n    4    -74.9409547085  -1.651e-01   7.125e-02     0.06     true     0.00\n    5    -74.9649972656  -2.404e-02   4.621e-02     0.00     true     0.00\n    6    -74.9650022441  -4.979e-06   7.385e-04     0.00     true     0.00\n    7    -74.9650028906  -6.464e-07   2.615e-04     0.00     true     0.00\n    8    -74.9650028947  -4.112e-09   1.362e-05     0.00     true     0.00\n    9    -74.9650028947  -3.979e-13   1.273e-07     0.13     true     0.00\n    10   -74.9650028947   0.000e+00   4.229e-08     0.00     true     0.00\n    11   -74.9650028947   0.000e+00   1.605e-08     0.00     true     0.00\n    12   -74.9650028947  -2.842e-14   1.155e-09     0.00     true     0.00\n    13   -74.9650028947  -2.842e-14   2.004e-10     0.00     true     0.00\n--------------------------------------------------------------------------------\n    RHF done in  0.43s\n    @Final RHF Energy         -74.965002894685 Eâ‚•\n\n   â€¢ Orbitals Summary\n\n    Orbital            Energy    Occupancy\n          1    -20.2459299842       â†¿â‡‚\n          2     -1.2522309022       â†¿â‡‚\n          3     -0.6007847377       â†¿â‡‚\n          4     -0.4490335937       â†¿â‡‚\n          5     -0.3893764439       â†¿â‡‚\n          6      0.5733840180\n          7      0.7039953043\n\n   âœ”  SCF Equations converged ðŸ˜„\n--------------------------------------------------------------------------------\n â‡’ Fermi Restricted Hartree--Fock Wave function\n â‹… Basis:                  sto-3g\n â‹… Energy:                 -74.96500289468506\n â‹… Occ. Spatial Orbitals:  5\n â‹… Vir. Spatial Orbitals:  2\nConvergence: Î”E => 2.84e-14 Dáµ£â‚˜â‚› => 2.00e-10","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Cclib.jl is a Julia wrapper around Cclib - an open source library written in Python for parsing and interpreting the results of computational chemistry packages.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Parsing outputs from 15 different programs: ADF, DALTON, Firefly, GAMESS (US), GAMESS-UK, Gaussian, Jaguar, Molpro, MOLCAS, MOPAC, NWChem, ORCA, Psi4, NBO, QChem and Turbomole.\nFurther analysis of calculation outputs, such as population analysis.\nIntegration with AtomsBase.jl - an interface for atomic geometries.\nBy extension, provides interoperability with libraries that use AtomsBase.jl, such as DFTK.jl, Molly.jl, and InteratomicPotentials.jl.\nIntegration with Fermi.jl - quantum chemistry framework written in Julia.","category":"page"},{"location":"#How-to-install","page":"Home","title":"How to install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install Cclib.jl, start up and type the following into the REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(\"Cclib\")","category":"page"},{"location":"io/#Reading-and-writing-files","page":"How to parse files","title":"Reading and writing files","text":"","category":"section"},{"location":"io/#Supported-formats","page":"How to parse files","title":"Supported formats","text":"","category":"section"},{"location":"io/","page":"How to parse files","title":"How to parse files","text":"Properties that can be parsed and supported file formats can be found here.","category":"page"},{"location":"io/#How-to-read-files","page":"How to parse files","title":"How to read files","text":"","category":"section"},{"location":"io/","page":"How to parse files","title":"How to parse files","text":"# Input files can be found in the in the repo under \"test\" folder\njulia> using Cclib\njulia> mol = ccread(\"uracil_two.xyz\")","category":"page"},{"location":"io/","page":"How to parse files","title":"How to parse files","text":"The data is now stored in mol variable. To see what data it contains, we can use the keys function that comes with the standard library.","category":"page"},{"location":"io/","page":"How to parse files","title":"How to parse files","text":"julia> keys(mol)\nKeySet for a Dict{String, Any} with 4 entries. Keys:\n  \"atomcoords\"\n  \"natom\"\n  \"atomnos\"\n  \"metadata\"","category":"page"},{"location":"io/","page":"How to parse files","title":"How to parse files","text":"Accessing the data is identical to how one would access data in a dictionary:","category":"page"},{"location":"io/","page":"How to parse files","title":"How to parse files","text":"julia> mol[\"natom\"]\n12","category":"page"},{"location":"io/#Adding-and/or-updating-properties","page":"How to parse files","title":"Adding and/or updating properties","text":"","category":"section"},{"location":"io/","page":"How to parse files","title":"How to parse files","text":"Once loaded, mol data is a regular Julia dictionary, and can be edited as such:","category":"page"},{"location":"io/","page":"How to parse files","title":"How to parse files","text":"julia> mol[\"myprop\"] = 5\njulia> mol[\"myprop\"]\n5","category":"page"}]
}
